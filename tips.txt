setting.py 

setting.py DB 설정 내용을 변경
DATABASES = {
	'default':{
		'ENGINE':
		
		
객체지향 프로그래밍 

github  	git init  -현재 지정해준 경로에 git저장소 생성
		rm -r .git init 취소
		git config -global user.name '사용자명'
		git config -global user.email '메일주소'
		
		git config --list 로 정상적으로 적용됐는지 확인
		
		대부분의 명령을 로컬에서 실행 한다는 점 오프라인 환경에서도 commit이 가능하다
		
		Git Repository 구조 - 작업폴더 > 인덱스 > 저장소
				저장소에 commit하기 위해 추가 변경하고자 하는 파일을 인덱스에 기록
				저장된 목록만 최종적으로 commit명령어에 의해 저장소에 공개
				
		git status 로컬 저장소의 현재 상태 확인
		git add -all 변경된 것을 모두 추가
		git add abc.py - 특정 파일만추가 
		git commit -m "Changed the HTML for the site." 수정된 내용을 커밋해준다(m 이름에 맞춰서)
		git log log기록들을 확인해 줄 수 있다
		git push 업로드해줌
		그 후에 pythonanywhere bash console에서 git pull 그럼 이 서버에 업로드된다
		
		git remote rm origin  - origin 삭제
		git remote add origin https://github.com/anjunpil/my-first-blogs.git 
			이 저장소에 별칭 origin 복제하면 origin 별칭 볼 수 있다
		git push -u origin master - commit상태 있는 내용들 원격저장소로 보냄
		git clone https://github.com/anjunpil/my-first-blogs.git 복제함
		git push origin master 나의 Repository로 push 하기
		git remote -v 원격저장소 위치주소 알수 있음
		git branch dataviz - dataviz란 새로운 branch 생성
		
		오류오류오류
		couldn't find remote ref master  오류 시 git checkout master 
							 git checkout -b master 새로운 master생성
		src refspec master does not match any git commit 을 해주지 않아서생기는 오류

		
pythonanywhere
		bash console클릭
		git clone
		tree 구조확인
		cd -n
		virtualenv --python=python3.6 myvenv 가상환경 다시 생성
		source myvenv/bin/activate 활성화
		pip install django~=2.0 django 도 다시 설치
		python manage.py migrate 다시 초기화시켜줌
		python manage.py createsuperuser 다시 생성
		
		git pull
		
djang queryset 
		queryset - 전달받은 객체의 목록
		Post.objects.all() 모델의 데이터 전체 조회  SELECT * FROM Post
		Post.objects.all().oredered_by('id')[:10] 특정 모델의 10개 데이터를 id순으로
		Post.objects.create(title='new title') 특정 모델의 새 row 저장 INSERT INTO ...
		SQL을 생성해 주는 인터페이스
		
		queryset = queryset.filter(조건필드1=조건값1,조건필드2=조건값2) 모델 전체에서 조건필드 1,2 추가
		queryset = queryset.filter(조건필드3=조건값3) 조건필드 1,2에 3추가


		from django.db.models import Q
		queryset.fillter(Q(조건필드1=조건값1)\Q(조건필드2= 조건값2))  OR  조건
		queryset.fillter(Q(조건필드1=조건값1)&Q(조건필드2= 조건값2))  AND 조건

		1)각 Model instance의 sava함수를 통해 저장
		model_instance = ModelCls(필드명1 = 값1 , 필드명2= 값2) #새로운 모델 
		print(model_instance.id) DB저장 전이므로 None값을 출력
		
		None
		
		model_instance.save() DB에 저장함
		print(model_instance.id) 자동으로 할당된 id값 출력
		2)model_instance = ModelCls.objects.create(필드명1=값1,필드명2=값2) DB에 저장
		print(model_instance.id)
		
		update
		1)queryset.update(tags='Python,Django')

		queryset =ModelCls.objects.all()
		queryset.delete()
		

		데이터베이스 DB로 전달/실행되는 SQL개수 줄이고 각 SQL 성능/처리속도 최적화필요
		로직 복잡도 :중요
		프로그래밍언어 종류 : 대개는 미미
		django-debug-toolbar(디버깅 라이브러리) - request/response에 다양한 디버깅 정보보여줌

	

		pip install -r requirements.txt 가상환경에서 다른 프로젝트를 망치지않게 해준다


		